"""
Plotter class for plotting utility.
"""

from typing import Callable, Optional

import torch

import numpy as np

import matplotlib.pyplot as plt
from matplotlib.axes import Axes
from matplotlib.animation import FuncAnimation


from .base_energy import BaseEnergy, HighDimensionalEnergy


class Plotter:
    def __init__(
        self,
        energy_function: BaseEnergy,
        plotting_bounds=(-10.0, 10.0),
        projection_dims: Optional[list[tuple[int, int]]] = None,
        fig_size: Optional[tuple[float, float]] = (12.0, 6.0),
        **kwargs,
    ):
        self.energy_function = energy_function
        self.need_projection = isinstance(energy_function, HighDimensionalEnergy)

        if self.need_projection and projection_dims is None:
            raise Exception("Please provide projection_dims for HighDimensionalEnergy")

        self.projection_dims = projection_dims

        # Figure settings
        self.fig_size = fig_size

        self.plotting_bounds = plotting_bounds

        self.grid_width_n_points = 200
        self.n_contour_levels = 50
        self.log_prob_min = -1000.0

        self.alpha = 0.3

    def draw_contour(
        self,
        ax: Axes,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        if self.need_projection:

            def log_prob_2D(x_2D: torch.Tensor) -> torch.Tensor:
                return -self.energy_function.energy_on_2d(x_2D, first_dim, second_dim)

            log_prob_func = log_prob_2D
        else:

            def log_prob(x: torch.Tensor) -> torch.Tensor:
                return -self.energy_function.energy(x)

            log_prob_func = log_prob

        return draw_2D_contour(
            ax,
            log_prob_func=log_prob_func,
            bounds=self.plotting_bounds,
            device=self.energy_function.device,
            grid_width_n_points=self.grid_width_n_points,
            n_contour_levels=self.n_contour_levels,
            log_prob_min=self.log_prob_min,
        )

    def draw_sample(
        self,
        sample: torch.Tensor,
        ax: Axes,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        """
        Make figure containing sample from the model.

        Args:
            sample (torch.Tensor): Sample generated by model.

        Return:
            fig, axs: matplotlib figure and axes object that is created.
        """
        if self.need_projection:
            sample = self.energy_function.projection_on_2d(
                sample, first_dim, second_dim
            )

        return draw_2D_sample(
            sample,
            ax,
            self.plotting_bounds,
            self.alpha,
        )

    def draw_vector_field(
        self,
        ax: Axes,
        vecfield: Callable[[torch.Tensor], torch.Tensor],
        device: str,
    ):
        """
        Draw vector field quiver plot on 2D plot.
        Here, given vf must be batch-support version.
        """

        X, Y = make_2D_meshgrid(self.plotting_bounds, self.grid_width_n_points // 20)

        points = get_points_on_2D_grid(
            self.plotting_bounds,
            self.grid_width_n_points // 20,
            device=device,
        )

        vectors = vecfield(points).detach()

        return ax.quiver(X, Y, vectors[:, 0], vectors[:, 1])

    def draw_contour_and_ground_truth_sample(
        self,
        ax: Axes,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        ground_truth_sample = self.energy_function.sample(batch_size=2000)
        self.draw_contour_and_sample(ground_truth_sample, ax, first_dim, second_dim)

        ax.set_title("Ground truth sample plot")

    def draw_contour_and_sample(
        self,
        sample: torch.Tensor,
        ax: Axes,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        self.draw_contour(ax, first_dim, second_dim)
        self.draw_sample(sample, ax, first_dim, second_dim)

        if self.need_projection:
            ax.set_title(f"Projected on x{first_dim}, x{second_dim}")

            ax.set_ylabel(f"x{first_dim}")
            ax.set_xlabel(f"x{second_dim}")
        else:
            ax.set_title(f"Sample plot")

    def make_sample_generation_animation(
        self,
        trajectory: torch.Tensor,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        """
        Make animation describing sample generation for given trajectory.

        Args:
            trajectory (torch.Tensor): sample generation trajectory from model.

        Return:
            animation, fig, axs: matplotlib animation, figure and axes object that is created.
        """
        trajectory_length = trajectory.size(1)

        fig, ax = plt.subplots(1, 1, figsize=(12, 12))

        self.draw_contour(ax, first_dim, second_dim)
        scatter_obj = self.draw_sample(trajectory[:, 0, :], ax, first_dim, second_dim)

        trajectory = trajectory.cpu().numpy()

        def update(frame: int):
            scatter_obj.set_offsets(trajectory[:, frame, :])

        animation = FuncAnimation(fig, update, frames=trajectory_length, interval=200)

        return animation, fig, ax

    def make_plot(self, sample: torch.Tensor):
        """
        Make figure containing sample from the model.

        Args:
            sample (torch.Tensor): Sample generated by model.

        Return:
            fig, axs: matplotlib figure and axes objec
            t that is created.
        """

        # Energy function is defined on high dimensional space.
        if self.need_projection:
            nrows = (len(self.projection_dims) + 1) // 2
            ncols = 2

            fig, axs = plt.subplots(nrows, ncols, figsize=self.fig_size)

            for (proj_dim_1, proj_dim_2), ax in zip(
                self.projection_dims, axs.flatten()
            ):
                self.draw_contour_and_sample(sample, ax, proj_dim_1, proj_dim_2)

        # Energy function is 2D.
        else:
            fig, axs = plt.subplots(1, 2, figsize=self.fig_size)
            self.draw_contour_and_ground_truth_sample(axs[0])
            self.draw_contour_and_sample(sample, axs[1])

        return fig, axs


def get_points_on_2D_grid(
    bounds: tuple, grid_width_n_points: int, device: Optional[str] = "cpu"
):
    """
    For points on the grid (bounds[0], bounds[1]) with n points at each side,
    make the list of points on the grid whose shape are (n**2, 2).
    """

    grid_lower_lim, grid_upper_lim = bounds

    x = torch.linspace(
        grid_lower_lim, grid_upper_lim, grid_width_n_points, device=device
    )
    y = torch.linspace(
        grid_lower_lim, grid_upper_lim, grid_width_n_points, device=device
    )

    points = torch.cartesian_prod(x, y)
    return points


def make_2D_meshgrid(bounds: tuple, grid_width_n_points: int):
    """
    For points on the grid (bounds[0], bounds[1]) with n points at each side,
    make meshgrid tensor X, Y whose shape are (n, n).
    """
    grid_lower_lim, grid_upper_lim = bounds

    x = torch.linspace(
        grid_lower_lim,
        grid_upper_lim,
        grid_width_n_points,
    )
    y = torch.linspace(
        grid_lower_lim,
        grid_upper_lim,
        grid_width_n_points,
    )

    return torch.meshgrid(x, y, indexing="ij")


def draw_2D_contour(
    ax: Axes,
    log_prob_func: Callable[[torch.Tensor], torch.Tensor],
    bounds: tuple,
    device: str = "cpu",
    grid_width_n_points: int = 200,
    n_contour_levels: int = 50,
    log_prob_min: float = -1000.0,
):
    """
    Plot contours of a log_prob func that is defined on 2D.
    This function returns contour object.

    :Args:
        device (str): device which log_prob_func resides on.
    """

    points = get_points_on_2D_grid(
        bounds=bounds, grid_width_n_points=grid_width_n_points, device=device
    )

    assert points.ndim == 2 and points.shape[1] == 2

    log_prob_x = log_prob_func(points).detach().cpu()

    log_prob_x = torch.clamp_min(log_prob_x, log_prob_min)

    log_prob_x = log_prob_x.reshape((grid_width_n_points, grid_width_n_points))

    X, Y = make_2D_meshgrid(bounds=bounds, grid_width_n_points=grid_width_n_points)

    return ax.contour(X, Y, log_prob_x, levels=n_contour_levels)


def draw_2D_sample(sample: torch.Tensor, ax: Axes, bounds: tuple, alpha: float = 0.5):
    """
    Draw 2D sample plot.
    This function returns scatter object.
    """
    plot_lower_lim, plot_upper_lim = bounds

    sample = sample.cpu().detach()
    sample = torch.clamp(sample, plot_lower_lim, plot_upper_lim)
    return ax.scatter(sample[:, 0], sample[:, 1], alpha=alpha, marker="o", s=10)
