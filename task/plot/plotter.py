from typing import Optional

import torch

import matplotlib.pyplot as plt
from matplotlib.axes import Axes
from matplotlib.animation import FuncAnimation

from .draw_plot import *
from .plot_config import CONFIG_FOR_ENERGY
from .projection import Projector

from ..energies import BaseEnergy, AnnealedDensities

from omegaconf import OmegaConf, DictConfig


class Plotter:
    def __init__(
        self,
        energy: BaseEnergy,
        **override_cfg: dict,
    ):
        self.energy = energy

        self._load_plot_config(energy.name, override_cfg)

        self._check_plot_availability()

        if energy.data_ndim > 2 and (self.can_plot_sample or self.can_plot_kde):
            self._init_projector()
            self.need_projection = True
        else:
            self.need_projection = False

    def _load_plot_config(self, energy_name: str, additional_config: dict):
        self.cfg: DictConfig = OmegaConf.merge(
            CONFIG_FOR_ENERGY[energy_name],
            OmegaConf.create(additional_config),
        )
        OmegaConf.resolve(self.cfg)

    def _check_plot_availability(self):
        self.can_plot_sample = bool(self.cfg.get("sample_figure"))
        self.can_plot_kde = bool(self.cfg.get("kde_figure"))
        self.can_plot_energy_hist = bool(self.cfg.get("energy_hist"))
        self.can_plot_interatomic_dist_hist = bool(self.cfg.get("interatomic_dist"))

    def _init_projector(self):
        if "projection_dims" not in self.cfg.sample_figure:
            raise Exception(
                "Please provide projection_dims for high dimensional energy"
            )
        self.projector = Projector(self.energy)

    def contour_plot(
        self,
        ax: Axes,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        if self.need_projection:

            def func(x: torch.Tensor) -> torch.Tensor:
                return -self.projector.energy_on_2d(x, first_dim, second_dim)

        else:

            def func(x: torch.Tensor) -> torch.Tensor:
                return -self.energy.energy(x)

        return draw_2D_contour(
            ax,
            func=func,
            device=self.energy.device,
            **OmegaConf.to_container(self.cfg.contour_plot),
        )

    def sample_plot(
        self,
        sample: torch.Tensor,
        ax: Axes,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        """
        Make figure containing sample from the model.

        Args:
            sample (torch.Tensor)

        Return:
            fig, axs: matplotlib figure and axes object that is created.
        """

        if self.need_projection:
            sample = self.projector.projection(sample, first_dim, second_dim)

        return draw_2D_sample(
            ax, sample, **OmegaConf.to_container(self.cfg.sample_plot)
        )

    def kde_plot(
        self,
        sample: torch.Tensor,
        ax: Axes,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        """
        Make figure containing KDE plot for sample.

        Args:
            sample (torch.Tensor): Sample generated by model.

        Return:
            fig, axs: matplotlib figure and axes object that is created.
        """
        if self.need_projection:
            sample = self.projector.projection(sample, first_dim, second_dim)

        return draw_2D_kde(sample, ax, **OmegaConf.to_container(self.cfg.kde_plot))

    def energy_hist(self, ax: Axes, sample: torch.Tensor, name: str = ""):
        log_reward = self.energy.log_reward(sample)
        draw_energy_histogram(
            ax, log_reward, name, range=self.cfg.energy_hist.energy_range
        )

    def draw_contour_and_sample(
        self,
        sample: torch.Tensor,
        ax: Axes,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
    ):
        self.contour_plot(ax, first_dim, second_dim)
        self.sample_plot(sample, ax, first_dim, second_dim)

        if self.need_projection:
            ax.set_title(f"Projected on x{first_dim}, x{second_dim}")

            ax.set_ylabel(f"x{second_dim}")
            ax.set_xlabel(f"x{first_dim}")
        else:
            ax.set_title(f"Sample plot")

    def make_trajectory_plot(
        self,
        trajectory: torch.Tensor,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
        fig_size: tuple = (12, 12),
    ):
        fig, ax = plt.subplots(1, 1, figsize=fig_size)

        self.contour_plot(ax, first_dim, second_dim)

        if self.need_projection:
            trajectory = self.projector.projection(trajectory, first_dim, second_dim)

        draw_trajectory_plot(ax, trajectory)

        return fig, ax

    def make_sample_generation_animation(
        self,
        trajectory: torch.Tensor,
        first_dim: Optional[int] = None,
        second_dim: Optional[int] = None,
        fig_size: tuple = (12, 12),
    ):
        """
        Make animation describing sample generation for given trajectory.

        Args:
            trajectory (torch.Tensor): sample generation trajectory from model.

        Return:
            animation, fig, axs: matplotlib animation, figure and axes object that is created.
        """
        trajectory_length = trajectory.size(1)

        fig, ax = plt.subplots(1, 1, figsize=fig_size)

        self.contour_plot(ax, first_dim, second_dim)
        scatter_obj = self.sample_plot(trajectory[:, 0, :], ax, first_dim, second_dim)

        trajectory = trajectory.cpu().numpy()

        def update(frame: int):
            scatter_obj.set_offsets(trajectory[:, frame, :])

        animation = FuncAnimation(fig, update, frames=trajectory_length, interval=200)

        return animation, fig, ax

    def make_sample_plot(self, sample: torch.Tensor):
        """
        Make figure containing sample from the model.

        Args:
            sample (torch.Tensor): Sample generated by model.

        Return:
            fig, axs: matplotlib figure and axes objec
            t that is created.
        """
        fig_size = self.cfg.sample_figure.fig_size

        # Energy function is defined on high dimensional space.
        if self.need_projection:
            projection_dims = self.cfg.sample_figure.projection_dims

            if len(projection_dims) == 1:
                fig, axs = plt.subplots(1, 1, figsize=fig_size)
                self.draw_contour_and_sample(sample, axs, *projection_dims[0])
            else:
                nrows = (len(projection_dims) + 1) // 2
                ncols = 2

                fig, axs = plt.subplots(nrows, ncols, figsize=fig_size)

                for (proj_dim_1, proj_dim_2), ax in zip(projection_dims, axs.flatten()):
                    self.draw_contour_and_sample(sample, ax, proj_dim_1, proj_dim_2)

        # Energy function is 2D.
        else:
            fig, axs = plt.subplots(1, 1, figsize=fig_size)
            self.draw_contour_and_sample(sample, axs)

        return fig, axs

    def make_kde_plot(self, sample: torch.Tensor):
        """KDE plot for sample."""
        fig_size = self.cfg.kde_figure.fig_size

        # Energy function is defined on high dimensional space.
        if self.need_projection:
            projection_dims = self.cfg.kde_figure.projection_dims

            if len(projection_dims) == 1:
                fig, axs = plt.subplots(1, 1, figsize=fig_size)
                self.kde_plot(sample, axs, *projection_dims[0])
            else:

                nrows = (len(projection_dims) + 1) // 2
                ncols = 2

                fig, axs = plt.subplots(nrows, ncols, figsize=fig_size)

                for (proj_dim_1, proj_dim_2), ax in zip(projection_dims, axs.flatten()):
                    self.kde_plot(sample, ax, proj_dim_1, proj_dim_2)

                    ax.set_title(f"Projected on x{proj_dim_1}, x{proj_dim_2}")
                    ax.set_ylabel(f"x{proj_dim_2}")
                    ax.set_xlabel(f"x{proj_dim_1}")

        # Energy function is 2D.
        else:
            fig, axs = plt.subplots(1, 1, figsize=fig_size)
            self.kde_plot(sample, axs)
            axs.set_title(f"KDE plot")

        return fig, axs

    def make_time_logZ_plot(
        self,
        annealed_density: AnnealedDensities,
        logZ_ratio: torch.Tensor,
        label: str = "Learned logZ_t",
    ):
        fig, ax = plt.subplots(1, 1, figsize=(8, 6))

        if annealed_density.energy_function.logZ_is_available:
            logZ_t = annealed_density.logZ_t(100000, logZ_ratio.size(0))
            draw_time_logZ_plot(ax, logZ_t, label="Exact")

        learned_logZ_t = (
            logZ_ratio.detach().cumsum(dim=0)
            + annealed_density.prior_energy.ground_truth_logZ
        )
        draw_time_logZ_plot(ax, learned_logZ_t, label=label)

        ax.legend()
        ax.grid(True)

        return fig, ax

    def make_energy_histogram(self, sample: torch.Tensor, name: str = ""):
        fig, ax = plt.subplots(1, 1, figsize=self.cfg.energy_hist.fig_size)
        self.energy_hist(ax, sample, name)
        return fig, ax

    def make_interatomic_distance_histogram(self, sample: torch.Tensor, name: str = ""):
        fig, ax = plt.subplots(1, 1, figsize=(8, 6))

        interatomic_dist = self.energy.interatomic_distance(sample).reshape(-1)

        draw_interatomic_dist_histogram(
            ax,
            interatomic_dist,
            name,
            **OmegaConf.to_container(self.cfg.interatomic_dist),
        )

        return fig, ax
